name: static-binary-analysis-with-llm
description: "perform static binary security analysis and reason about anti-analysis: memory corruption and malware indicators with LLM"

inputs:
  - name: path
    type: string
    required: true

pre_scripts:
  - ./scripts/static_script.py {{path}}
static_path: ./static/
llm_prompt: |
  You are an AI security analyst specialized in static code malware detection.
  Analyze the following static_script outputs for binaries or sourcecode:
  - Binwalk scan (embedded files, compression, entropy):
    {{static_path}}/{{path}}.binwalk.log
  - Checksec report (RELRO, NX, PIE, stack canaries):
    {{static_path}}/{{path}}.checksec.log
  - File command output (binary type, architecture, stripping, linking):
    {{static_path}}/{{path}}.file.log
  - Hexdump and extracted strings (shellcode patterns, encoded blobs):
    {{static_path}}/{{path}}.hexdump.log
  - LDD output (runtime dependencies, loader hijacking potential):
    {{static_path}}/{{path}}.ldd.log
  - MD5 hash (basic fingerprinting / weak hash comparison):
    {{static_path}}/{{path}}.md5sum.log
  - NM symbols (exported/imported symbols, unsafe functions):
    {{static_path}}/{{path}}.nm.log
  - Objdump disassembly (instructions, syscalls, anti-analysis):
    {{static_path}}/{{path}}.objdump.log
  - Patchelf output (RPATH/RUNPATH, interpreter modification):
    {{static_path}}/{{path}}.patchelf.log
  - ROP gadget scan (available gadgets and syscall sequences):
    {{static_path}}/{{path}}.ropgadget.log
  - SHA256 hash (strong fingerprinting):
    {{static_path}}/{{path}}.sha256sum.log
  - SSDeep fuzzy hash (similarity to known malware families):
    {{static_path}}/{{path}}.ssdeep.log
  - ReadElf output (sections, headers, dynamic linking info):
    {{static_path}}/{{path}}.readelf.log
  - Strings extraction (potential shellcode, hidden strings):
    {{static_path}}/{{path}}.strings.log
  Correlate findings across tools.
  Do not assume maliciousness from a single indicator.
  Detect:
  - Anti-debugging, anti-analysis, and obfuscation
  - Unsafe or dangerous functions
  - Shellcode, payloads, or embedded malicious content
  - Exploit techniques (ROP, gadgets)
  - Memory corruption risk (GOT/PLT issues)
  - Environment hijacking risk
  - Packing or self-extracting binaries
  - Malware family correlations

  1. **Instruction-level indicators (isa-instructions)**  
     Look for suspicious instructions like `rdtsc` (timing anti-debug), `cpuid` (VM/sandbox detection), raw syscalls (`int 0x80`, `syscall`, `sysenter`), `hlt`, interrupt manipulation (`cli`, `sti`), and I/O port access (`in`, `out`). Multiple such instructions or inline assembly in high-level code increases suspicion.
  2. **GOT/PLT / Dynamic Linking Checks**  
     Analyze RELRO, BIND_NOW, stack protection, and executable stack. Patterns like missing RELRO, partial RELRO with lazy binding, or RWX segments indicate runtime GOT overwrites, delayed symbol resolution, or critical memory corruption risk.
  3. **Sections and Binary Layout**  
     Examine section sizes, entropy, and naming. High entropy (>7) without readable strings suggests packing or encryption. Code in W sections or data in executable sections is highly suspicious.
  4. **Shellcode and Payload Indicators**  
     Look for `/bin/sh`, NOP sleds (`\x90\x90\x90`), raw syscalls, hardcoded IPs/domains, base64 or XOR blobs. Presence in `.text` or high-entropy sections increases severity.
  5. **Environment Hijacking / Loader Manipulation**  
     Check for risky LD_* variables (LD_PRELOAD, LD_LIBRARY_PATH, LD_AUDIT, LD_DEBUG) and unsafe RPATHs (`.`, `/tmp`, user-writable directories) that could allow code injection at load time.
  6. **Symbols and Functions**  
     Look for dangerous functions (`system`, `execve`, `popen`, `gets`, `strcpy`, `sprintf`) or exported internal symbols. Missing stack protection or obfuscated symbols are additional risk indicators.
  7. **ROP Gadgets**  
     Scan for high gadget density, `pop-ret` or `syscall-ret` sequences, or gadgets in writable/nonstandard sections. These indicate potential exploit techniques.
  8. **Packing and Embedded Content**  
     Identify compressed or encrypted blobs, embedded ELF files, or self-extracting content, often indicative of droppers or packed malware.
  9. **Multithreading / Concurrency**  
     Look for `pthread_create`, `clone`, `futex`, resource spinlocks, manual TLS, or lock-free primitives that may be used for anti-debugging or obfuscation.
  10. **Hash and Similarity Analysis**  
      Compare SHA256 and fuzzy hashes (ssdeep) to known malware. High similarity, minor variants, or known malware hashes suggest possible family classification.
  Correlate findings across all these areas. Avoid relying on a single indicator. Output:
    - **Severity**: INFORMATIONAL / MEDIUM / HIGH / CRITICAL  
    - **Category**: e.g., anti-analysis, memory-corruption, shellcode, unsafe-functions  
    - **Message**: describe the observed risk  
    - **Evidence**: relevant log snippets  

  Provide a final risk level: SAFE / SUSPICIOUS / DANGEROUS

post_scripts:
  - ./scripts/format_findings_report.py {{llm_output}}

outputs:
  - risk_level
  - findings_report_path
