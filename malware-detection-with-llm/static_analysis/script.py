import os
import pathlib
import sys
import threading
import subprocess
import ast
import json
import astroid

source_extensions = [".py", ".c", ".cpp", ".rs", ".sh", ".java"]

def is_executable(path: str) -> bool:
    return os.access(path, os.X_OK)

#standard on Linux
def is_elf(path: str) -> bool:
    try:
        with open(path, "rb") as f:
            header = f.read(16)
            if len(header) < 16:
                return False
            if header[:4] != b"\x7fELF":
                return False
            if header[4] not in (1, 2):
                return False
            if header[5] not in (1, 2):
                return False
            return True
    except Exception:
        return False
    
#standard on Windows
def is_pe(path: str) -> bool:
    try:
        with open(path, "rb") as f:
            magic = f.read(2)
            if magic != b"MZ":
                return False
            f.seek(0x3C)
            pe_offset = int.from_bytes(f.read(4), "little")
            f.seek(pe_offset)
            pe_sig = f.read(4)
            return pe_sig == b"PE\x00\x00"
    except Exception:
        return False

#standard on macOS / iOS
def is_mach_o(path: str) -> bool:
    try:
        with open(path, "rb") as f:
            header = f.read(4)
            if len(header) < 4:
                return False
            mach_o_magics = [b"\xFE\xED\xFA\xCE",
                             b"\xFE\xED\xFA\xCF",
                             b"\xCA\xFE\xBA\xBE"]
            return header in mach_o_magics
    except Exception:
        return False

from abc import ABC, abstractmethod
from pathlib import Path

#interface for static analysis tools with default run method
class StaticTool(ABC):
    name: str
    @abstractmethod
    def command(self, path: str) -> list[str]:
        #command to execute
        pass
    def run(self, path: str) -> None:
        log_dir = "static"
        os.makedirs(log_dir, exist_ok=True)
        log_file = os.path.join(log_dir, f"{path}.{self.name}.log")
        with open(log_file, "w") as f:
            subprocess.run(self.command(path), stdout=f, stderr=f, check=False)
        print(f"{self.name}:log saved to {log_file}")

class ReadElf(StaticTool):
    name = "readelf"
    def command(self, path):
        return ["readelf", "-h", "-S", "-l", path]
class ObjDump(StaticTool):
    name = "objdump"
    def command(self, path):
        return ["objdump", "-d", path]
class Strings(StaticTool):
    name = "strings"
    def command(self, path):
        return ["strings", "-a", path]
class NM(StaticTool):
    name = "nm"
    def command(self, path):
        return ["nm", "-a", path]
class LddSafe(StaticTool):
    name = "ldd"
    def command(self, path):
        return ["env", "LD_TRACE_LOADED_OBJECTS=1", "ldd", path]
class Checksec(StaticTool):
    name = "checksec"
    def command(self, path):
        return ["checksec", "--file", path]
class FileCmd(StaticTool):
    name = "file"
    def command(self, path):
        return ["file", path]
class Sha256(StaticTool):
    name = "sha256sum"
    def command(self, path):
        return ["sha256sum", path]
class Md5(StaticTool):
    name = "md5sum"
    def command(self, path):
        return ["md5sum", path]
class Ssdeep(StaticTool):
    name = "ssdeep"
    def command(self, path):
        return ["ssdeep", path]
class Hexdump(StaticTool):
    name = "hexdump"
    def command(self, path):
        return ["hexdump", "-C", path]
class Binwalk(StaticTool):
    name = "binwalk"
    def command(self, path):
        return ["binwalk", path]
class ROPGadgetTool(StaticTool):
    name = "ropgadget"
    def command(self, path):
        return ["ROPgadget", "--binary", path]
class Patchelf(StaticTool):
    name = "patchelf"
    def command(self, path):
        return ["patchelf", "--print-rpath", path]

DANGEROUS_CALLS = {
    "eval",
    "exec",
    "compile",
    "__import__",
    "getattr",
    "setattr",
    "delattr",
    "hasattr",
    "globals",
    "locals",
    "vars",
    "dir",
    "system",
    "popen",
    "spawn",
    "fork",
    "execv",
    "execve",
    "execl",
    "execlp",
    "loads",
    "load",
    "dumps",
    "open",#combined with exec/eval
    "input",
    "__builtins__",
    "__dict__",
}

class ASTScanner(ast.NodeVisitor):
    def __init__(self):
        self.findings = []

    def visit_Call(self, node):
        if isinstance(node.func, ast.Name):
            if node.func.id in DANGEROUS_CALLS:
                self.findings.append({
                    "type": "dangerous_call",
                    "name": node.func.id,
                    "line": node.lineno
                })
        self.generic_visit(node)    

def run_ast(src: Path, base: Path) -> None:
    tree = ast.parse(src.read_text())
    scanner = ASTScanner()
    scanner.visit(tree)
    out1 = base.with_suffix(".ast.json")
    out1.write_text(json.dumps(scanner.findings, indent=2))
    out2 = base.with_suffix(".ast.txt")
    dump = ast.dump(tree, annotate_fields=False, include_attributes=False,indent=2) #Depending on True/False the file size varies a lot
    with open(out2, "w", encoding="utf-8") as f:
        f.write(dump)

SUSPICIOUS_MODULES = {
    "subprocess",
    "os",
    "pty",
    "socket",
    "ssl",
    "http",
    "urllib",
    "urllib2",
    "requests",
    "websocket",
    "ctypes",
    "cffi",
    "mmap",
    "importlib",
    "imp",
    "pickle",
    "marshal",
    "shelve",
    "sys",
    "site",
    "atexit",
    "base64",
    "zlib",
    "bz2",
    "lzma",
    "codecs",
    "hashlib",
    "cryptography",
    "Crypto",
    "platform",
    "getpass",
    "pwd",
    "grp",
    "zipimport",
    "pkgutil",
    "runpy",
}


class Bandit(StaticTool):
    name = "bandit"
    def command(self, path: str) -> list[str]:
        return [
            "bandit",
            "-q",
            "-f", "json",
            path
        ]

def run_astroid(src: Path, base: Path):
    mod = astroid.parse(src.read_text())
    findings = []
    for node in mod.body:
        if isinstance(node, astroid.Import):
            for name, _ in node.names:
                if name in SUSPICIOUS_MODULES:
                    findings.append({
                        "type": "suspicious_import",
                        "module": name,
                        "line": node.lineno
                    })

        if isinstance(node, astroid.ImportFrom):
            if node.modname in SUSPICIOUS_MODULES:
                findings.append({
                    "type": "suspicious_import",
                    "module": node.modname,
                    "line": node.lineno
                })
    out = base.with_suffix(".astroid.json")
    out.write_text(json.dumps(findings, indent=2))    

def sourcecode(path: str)-> None:
    #Todo
    src = Path(path)
    out_dir = Path("./static")
    out_dir.mkdir(parents=True, exist_ok=True)
    base = out_dir / src.stem
    if path.endswith(".py"):
        print(f"Detected Python source code: {path}")
        threads = []
        t1 = threading.Thread(target=run_ast, args=(src, base), name="AST-thread")
        t1.start()
        threads.append(t1)
        t2 = threading.Thread(target=run_astroid, args=(src, base), name="ASTROID-thread")
        t2.start()
        threads.append(t2)
        bandit = Bandit()
        t3 = threading.Thread(target=bandit.run, args=(path,), name=f"{bandit.name}-thread")
        t3.start()
        threads.append(t3)
        strings = Strings()
        t4 = threading.Thread(target=strings.run, args=(path,), name=f"{strings.name}-thread")
        t4.start()
        threads.append(t4)
        for t in threads:
            t.join()
    elif path.endswith(".java"):
        print(f"Detected Java source code: {path}")
        #TODO
    
"""
Only one thread at a time can execute Python bytecode in a process
even if we have multiple CPU cores (GIL). Paralelism is achieved using a sepparate thread
for each command runed.
"""
def binarycode(path: str) -> None:
    if is_elf(path):
        print(f"Detected ELF binary: {path}")
    elif is_pe(path):
        print(f"Detected PE binary: {path}")
    elif is_mach_o(path):
        print(f"Detected Mach-O binary: {path}")
    else:
        print(f"!Unknown binary format: {path}")
    tools = [
        ReadElf(), ObjDump(), Strings(),
        NM(), LddSafe(), Checksec(), FileCmd(),
        ROPGadgetTool(), Hexdump(), Binwalk(),
        Sha256(), Md5(), Ssdeep(), Patchelf()]
    threads = []
    for tool in tools:
        t = threading.Thread(target=tool.run, args=(path,), name=f"{tool.name}-thread")
        t.start()
        threads.append(t)
    for t in threads:
        t.join()
    """
    @Ghidra integration (disabled for now)
    binary = pathlib.Path(path)
    project_dir = pathlib.Path("/tmp/ghidra_proj")
    script_dir = pathlib.Path("/scripts")
    ghidra_headless = "/opt/ghidra_10.3.5_PUBLIC/support/analyzeHeadless"
    subprocess.run([
        ghidra_headless,
        str(project_dir),
        "MalwareDetect - cdl25",
        "-import", str(binary),
        "-scriptPath", str(script_dir),
        "-postScript", "ExportDecompiled.java",
        "-overwrite"
    ], check=True)
    """
    
def main():
    assert len(sys.argv) > 1, "The path of the code must be passed as an argument"
    path = sys.argv[1]
    if any(path.endswith(ext) for ext in source_extensions):
        sourcecode(path)
    elif is_executable(path):
        binarycode(path)


if __name__ == "__main__":
    main()
